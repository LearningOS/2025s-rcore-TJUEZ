# 实现的功能
为TCB添加了计数器及相应函数，在syscall时对task的系统调用次数++，并在调用sys_trace时返回调用次数。
## 遇到的问题
核心问题就是MAX_SYSCALL_NUM的大小，在测试时发现，当MAX_SYSCALL_NUM=1024时和MAX_SYSCALL_NUM=1256时，测试会出错,前者的原因是超过最大值会引起爆栈（据课程所说），或者原因可能是太小了导致计数溢出
# 简答作业
- 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请同学们可以自行测试这些内容（运行三个 bad 测例 (ch2b_bad_*.rs)），描述程序出错行为，同时注意注明你使用的 sbi 及其版本。

- 回答 ：
  当 U 态程序尝试执行 S 态特权指令（比如 sret ）或访问 S 态特权寄存器（比如直接读写 sstatus 、 sepc ）时，CPU 会捕获到这种非法操作，并产生一个“非法指令”异常（Illegal Instruction）。
  随后，控制权会转移到内核的异常处理程序（ __alltraps -> trap_handler ）。内核会识别出这是个非法指令异常，通常会打印错误信息（包括异常类型、出错的指令地址等），然后终止这个用户程序。
  使用的 SBI 是 RustSBI 。
- 深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:

- L40：刚进入 __restore 时， sp 代表了什么值。请指出 __restore 的两种使用情景。
  
  - 回答 ：
    - sp 的值：指向当前任务 内核栈 上的 TrapContext （保存了任务的用户态上下文）。
    - 使用情景：
      1. 从系统调用、异常或中断处理完毕后，返回用户态。
      2. 任务切换时，恢复新任务的用户态上下文并开始执行。
- L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。
  
  ```
  ld t0, 32*8(sp)
  ld t1, 33*8(sp)
  ld t2, 2*8(sp)
  csrw sstatus, t0
  csrw sepc, t1
  csrw sscratch, t2
  ```
  - 回答 ：
    - 特殊处理了 sstatus 、 sepc 和 sscratch （间接用到了用户 sp ）。
    - sstatus ：恢复它能确保 sret 后能正确返回用户态（通过 SPP 位），并恢复中断状态等。
    - sepc ：保存了用户态发生陷阱时下一条要执行的指令地址， sret 会跳转到这里。
    - sscratch （这里存了用户 sp ）：用于后续配合 csrrw sp, sscratch, sp 指令，将 CPU 的栈指针从内核栈切换回用户栈。
- L50-L56：为何跳过了 x2 和 x4 ？
  
  ```
  ld x1, 1*8(sp)
  ld x3, 3*8(sp)
  .set n, 5
  .rept 27
     LOAD_GP %n
     .set n, n+1
  .endr
  ```
  - 回答 ：
    - x2 (sp)：用户栈指针 sp 是通过 sscratch 和 csrrw 指令特殊恢复的，不能在这里直接加载，否则会过早改变内核栈指针，导致后续加载出错。
    - x4 (tp)：线程指针 tp 在当前实验阶段可能未使用，或者其值是全局共享的，不需要在任务上下文切换时单独保存和恢复。
- L60：该指令之后， sp 和 sscratch 中的值分别有什么意义？
  
  ```
  csrrw sp, sscratch, sp
  ```
  - 回答 ：
    - sp (栈指针 x2 )：变成了 用户栈指针 （之前存在 sscratch 里的值）。
    - sscratch ：变成了 内核栈指针 （之前 sp 的值，指向 TrapContext ）。
- __restore ：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？
  
  - 回答 ：
    - 状态切换指令： sret 。
    - 为何进入用户态： sret 会将 pc 指向 sepc （用户态指令地址），并根据 sstatus 中的 SPP 位（此时应为0，代表 U 态）将 CPU 特权级降为用户态。
- L13 ( __alltraps )：该指令之后， sp 和 sscratch 中的值分别有什么意义？
  
  ```
  csrrw sp, sscratch, sp // 假设这是 __alltraps 开头的栈切换指令
  ```
  - 回答 ：
    - sp (栈指针 x2 )：变成了 内核栈指针 （之前 sscratch 存的，指向当前任务的内核栈）。
    - sscratch ：变成了 用户栈指针 （之前 sp 的值，即发生 trap 时的用户栈顶）。
- 从 U 态进入 S 态是哪一条指令发生的？
  
  - 回答 ：主要是 ecall 指令（用于发起系统调用）。此外，发生异常或中断时也会被动从 U 态切换到 S 态。
# 荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
无
此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

https://cloud.tsinghua.edu.cn/f/17a7c9d9b57f4838ae5f/

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。